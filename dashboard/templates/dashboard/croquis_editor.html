{% extends 'dashboard/base.html' %}
{% load static %}

{% block title %}Editor de Croquis - Sushi Restaurant{% endblock %}

{% block content %}
{% csrf_token %}
<div class="d-flex justify-content-between align-items-start mb-4">
    <div>
        <h1 class="h3 mb-1 d-flex align-items-center">
            <i class="fas fa-drafting-compass me-2 text-primary"></i>
            Editor de Croquis
        </h1>
        <p class="text-muted mb-0">Dise√±a la distribuci√≥n visual de tu restaurante</p>
    </div>
    <div class="d-flex gap-2">
        <button class="btn btn-outline-primary" onclick="cargarLayout()">
            <i class="fas fa-folder-open me-1"></i>Cargar Layout
        </button>
        <button class="btn btn-success" onclick="guardarLayout()">
            <i class="fas fa-save me-1"></i>Guardar Layout
        </button>
        <button class="btn btn-outline-info" onclick="crearLayoutPredefinido()">
            <i class="fas fa-magic me-1"></i>Layout Base
        </button>
    </div>
</div>

<!-- Informaci√≥n de la sucursal -->
<div class="row mb-4">
    <div class="col-12">
        <div class="card">
            <div class="card-body">
                <h6 class="card-title d-flex align-items-center">
                    <i class="fas fa-building me-2"></i>{{ sucursal.nombre }}
                </h6>
                <p class="text-muted mb-0">{{ sucursal.direccion }}</p>
            </div>
        </div>
    </div>
</div>

<!-- Configuraci√≥n de dimensiones y pisos -->
<div class="row mb-4">
    <div class="col-md-8">
        <div class="card">
            <div class="card-header">
                <h6 class="mb-0">
                    <i class="fas fa-ruler-combined me-2"></i>Configuraci√≥n del Espacio
                </h6>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-3">
                        <label class="form-label small">Ancho (metros)</label>
                        <input type="number" id="anchoMetros" class="form-control form-control-sm" 
                               value="15" min="5" max="50" onchange="actualizarDimensiones()">
                    </div>
                    <div class="col-md-3">
                        <label class="form-label small">Alto (metros)</label>
                        <input type="number" id="altoMetros" class="form-control form-control-sm" 
                               value="10" min="5" max="50" onchange="actualizarDimensiones()">
                    </div>
                    <div class="col-md-3">
                        <label class="form-label small">Escala</label>
                        <select id="escalaSelect" class="form-select form-select-sm" onchange="actualizarDimensiones()">
                            <option value="20">1m = 20px</option>
                            <option value="30" selected>1m = 30px</option>
                            <option value="40">1m = 40px</option>
                            <option value="50">1m = 50px</option>
                        </select>
                    </div>
                    <div class="col-md-3">
                        <label class="form-label small">Canvas</label>
                        <div class="text-muted small" id="dimensionesInfo">450 x 300 px</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="col-md-4">
        <div class="card">
            <div class="card-header">
                <h6 class="mb-0">
                    <i class="fas fa-layer-group me-2"></i>Gesti√≥n de Pisos
                </h6>
            </div>
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <span class="small">Piso Actual:</span>
                    <div class="btn-group btn-group-sm" role="group">
                        <button type="button" id="piso-1" class="btn btn-outline-primary piso-btn active" onclick="cambiarPiso(1)">1</button>
                        <button type="button" id="piso-2" class="btn btn-outline-primary piso-btn" onclick="cambiarPiso(2)">2</button>
                        <button type="button" id="piso-3" class="btn btn-outline-primary piso-btn" onclick="cambiarPiso(3)">3</button>
                    </div>
                </div>
                <div class="d-flex gap-1">
                    <button class="btn btn-success btn-sm flex-fill" onclick="agregarPiso()" title="Agregar piso">
                        <i class="fas fa-plus"></i> Agregar
                    </button>
                    <button class="btn btn-danger btn-sm flex-fill" onclick="eliminarPiso()" title="Eliminar piso actual">
                        <i class="fas fa-trash"></i> Eliminar
                    </button>
                </div>
                <div class="mt-2">
                    <small class="text-muted">Objetos en piso <span id="objetosPisoActual">1</span>: <span id="contadorObjetos">0</span></small>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Panel de herramientas -->
<div class="row mb-4">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h6 class="mb-0">
                    <i class="fas fa-tools me-2"></i>Herramientas de Dise√±o
                </h6>
            </div>
            <div class="card-body p-3">
                <!-- Herramientas b√°sicas -->
                <div class="row">
                    <div class="col-lg-12 mb-3">
                        <div class="btn-group flex-wrap" role="group">
                            <button type="button" id="tool-seleccionar" class="btn btn-outline-primary tool-active" onclick="seleccionarHerramienta('seleccionar')">
                                <i class="fas fa-mouse-pointer"></i> Seleccionar
                            </button>
                            <button type="button" id="tool-pan" class="btn btn-outline-primary" onclick="seleccionarHerramienta('pan')">
                                <i class="fas fa-hand-paper"></i> Pan
                            </button>
                            <button type="button" id="tool-mesa" class="btn btn-outline-primary" onclick="seleccionarHerramienta('mesa')">
                                <i class="fas fa-table"></i> Mesa
                            </button>
                            <button type="button" id="tool-silla" class="btn btn-outline-primary" onclick="seleccionarHerramienta('silla')">
                                <i class="fas fa-chair"></i> Silla
                            </button>
                            <button type="button" id="tool-pared" class="btn btn-outline-primary" onclick="seleccionarHerramienta('pared')">
                                <i class="fas fa-square"></i> Pared
                            </button>
                            <button type="button" id="tool-puerta" class="btn btn-outline-primary" onclick="seleccionarHerramienta('puerta')">
                                <i class="fas fa-door-open"></i> Puerta
                            </button>
                            <button type="button" id="tool-barra" class="btn btn-outline-primary" onclick="seleccionarHerramienta('barra')">
                                <i class="fas fa-wine-glass"></i> Barra
                            </button>
                            <button class="btn btn-outline-danger" onclick="limpiarPiso()">
                                <i class="fas fa-broom"></i> Limpiar
                            </button>
                            <button class="btn btn-outline-secondary" onclick="alternarCuadricula()">
                                <i class="fas fa-th"></i> Cuadr√≠cula
                            </button>
                            <button class="btn btn-outline-info" onclick="recentrarVista()">
                                <i class="fas fa-search-minus"></i> Recentrar
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Editor Principal -->
<div class="row">
    <!-- Canvas del editor -->
    <div class="col-lg-9">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h6 class="mb-0">
                    <i class="fas fa-paint-brush me-2"></i>√Årea de Dise√±o
                </h6>
                <div class="d-flex gap-2">
                    <small class="text-muted">Zoom:</small>
                    <button class="btn btn-sm btn-outline-secondary" onclick="zoomOut()">
                        <i class="fas fa-search-minus"></i>
                    </button>
                    <span id="zoomLevel" class="text-muted small">100%</span>
                    <button class="btn btn-sm btn-outline-secondary" onclick="zoomIn()">
                        <i class="fas fa-search-plus"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-info" onclick="ajustarTama√±o()">
                        <i class="fas fa-expand-arrows-alt"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-warning" onclick="centrarVista()">
                        <i class="fas fa-crosshairs"></i>
                    </button>
                </div>
            </div>
            <div class="card-body p-0">
                <div id="canvasContainer" class="position-relative overflow-hidden" style="height: 700px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);">
                    <canvas id="croquiCanvas" width="450" height="300" 
                            style="border: 3px solid #007bff; cursor: crosshair; border-radius: 8px;"
                            class="shadow-sm canvas-bordered"></canvas>
                    
                    <!-- Indicador de piso actual -->
                    <div class="floor-indicator" id="indicadorPiso">
                        Piso 1
                    </div>
                    
                    <!-- Informaci√≥n de escala -->
                    <div class="scale-info" id="infoEscala">
                        1m = 30px
                    </div>
                    
                    <!-- Indicadores de coordenadas -->
                    <div class="coordenadas" id="coordenadasDiv" style="position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.8); color: white; padding: 8px 12px; border-radius: 6px; font-family: monospace; font-size: 0.8rem;">
                        X: 0m, Y: 0m
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Panel lateral -->
    <div class="col-lg-3">
        <!-- Propiedades del objeto seleccionado -->
        <div class="card mb-3">
            <div class="card-header">
                <h6 class="mb-0">
                    <i class="fas fa-cogs me-2"></i>Propiedades
                </h6>
            </div>
            <div class="card-body">
                <div id="propiedadesPanel">
                    <p class="text-muted text-center">
                        <i class="fas fa-hand-pointer fa-2x mb-2 d-block"></i>
                        Selecciona un objeto para ver sus propiedades
                    </p>
                </div>
            </div>
        </div>
        
        <!-- Lista de mesas -->
        <div class="card">
            <div class="card-header">
                <h6 class="mb-0">
                    <i class="fas fa-list me-2"></i>Mesas de la Sucursal
                </h6>
            </div>
            <div class="card-body">
                <div id="listaMesas">
                    <!-- Se cargar√° din√°micamente -->
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_css %}
<style>
/* Estilos para el editor de croquis */
.canvas-container {
    background-image: 
        linear-gradient(to right, #e9ecef 1px, transparent 1px),
        linear-gradient(to bottom, #e9ecef 1px, transparent 1px);
    background-size: 20px 20px;
}

.tool-active {
    background-color: var(--bs-primary) !important;
    color: white !important;
    border-color: var(--bs-primary) !important;
}

.objeto-seleccionado {
    box-shadow: 0 0 0 2px #007bff;
}

.mesa-canvas {
    border: 2px solid #28a745;
    background: rgba(40, 167, 69, 0.1);
    border-radius: 8px;
}

.pared-canvas {
    background: #6c757d;
}

.puerta-canvas {
    border: 2px solid #ffc107;
    background: rgba(255, 193, 7, 0.2);
}

.barra-canvas {
    border: 2px solid #fd7e14;
    background: rgba(253, 126, 20, 0.1);
    border-radius: 4px;
}

/* Estilos para la configuraci√≥n de dimensiones */
.dimension-info {
    font-family: 'Courier New', monospace;
    font-size: 0.8em;
}

/* Estilos para la gesti√≥n de pisos */
.piso-btn.active {
    background-color: var(--bs-primary) !important;
    color: white !important;
    border-color: var(--bs-primary) !important;
}

/* Cuadr√≠cula mejorada */
.grid-overlay {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
    opacity: 0.3;
}

/* Canvas con l√≠mites definidos */
.canvas-bordered {
    border: 3px solid #007bff !important;
    box-shadow: 0 0 10px rgba(0,123,255,0.3);
}

/* Informaci√≥n de escala */
.scale-info {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-family: monospace;
    font-size: 0.8rem;
}

/* Indicador de piso actual */
.floor-indicator {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(13, 110, 253, 0.9);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-weight: bold;
}

/* Panel de propiedades */
.property-group {
    margin-bottom: 1rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid #e9ecef;
}

.property-group:last-child {
    border-bottom: none;
    margin-bottom: 0;
}

.property-label {
    font-size: 0.875rem;
    font-weight: 600;
    color: #495057;
    margin-bottom: 0.5rem;
}

/* Lista de mesas */
.mesa-item {
    padding: 0.5rem;
    border: 1px solid #e9ecef;
    border-radius: 4px;
    margin-bottom: 0.5rem;
    background: white;
    cursor: pointer;
    transition: all 0.2s;
}

.mesa-item:hover {
    background: #f8f9fa;
    border-color: #007bff;
}

.mesa-item.mesa-ubicada {
    background: rgba(40, 167, 69, 0.1);
    border-color: #28a745;
}

.mesa-item.mesa-ubicada .badge {
    background: #28a745;
}
</style>
{% endblock %}

{% block extra_js %}
<script>
// Variables globales del editor
let canvas, ctx;
let herramientaActual = 'seleccionar';
let objetoSeleccionado = null;
let objetos = [];
let mesasDisponibles = [];
let isDragging = false;
let dragOffset = { x: 0, y: 0 };
let zoom = 1;
let panOffset = { x: 0, y: 0 };
let pisoActual = 1;
let objetosPorPiso = { 1: [], 2: [], 3: [] };
let pisosDisponibles = [1]; // Pisos disponibles

// Variables para pan
let isPanning = false;
let panStartPos = { x: 0, y: 0 };
let lastMouseX = 0;
let lastMouseY = 0;

// Configuraci√≥n de dimensiones y escala
let anchoMetros = 15;
let altoMetros = 10;
let escalaPixelsPorMetro = 30; // 1 metro = 30 p√≠xeles por defecto
let canvasWidth = 450; // anchoMetros * escalaPixelsPorMetro
let canvasHeight = 300; // altoMetros * escalaPixelsPorMetro
let cuadriculaVisible = true;
let cuadriculaTama√±o = 30; // Tama√±o de la cuadr√≠cula en p√≠xeles (1 metro)

// Variable global para sucursal ID
const SUCURSAL_ID = {{ sucursal.id }};

// üé® INICIALIZACI√ìN DEL CANVAS
function inicializarCanvas() {
    console.log('üé® Inicializando canvas del editor de croquis...');
    
    canvas = document.getElementById('croquiCanvas');
    if (!canvas) {
        console.error('‚ùå No se pudo encontrar el elemento canvas con ID "croquiCanvas"');
        return false;
    }
    
    ctx = canvas.getContext('2d');
    if (!ctx) {
        console.error('‚ùå No se pudo obtener el contexto 2D del canvas');
        return false;
    }
    
    // Configurar eventos del canvas
    canvas.addEventListener('mousedown', onMouseDown);
    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('wheel', onWheel);
    canvas.addEventListener('dblclick', onDoubleClick); // Agregar doble-click para rotaci√≥n
    
    console.log('‚úÖ Canvas inicializado correctamente');
    
    // Dibujar por primera vez
    redraw();
    
    return true;
}

// üé® FUNCIONES DE DIBUJO MEJORADAS

// Funci√≥n para dibujar cuadr√≠cula visible
function dibujarCuadricula() {
    if (!cuadriculaVisible) return;
    
    ctx.save();
    ctx.strokeStyle = '#e2e8f0';
    ctx.lineWidth = 0.5;
    ctx.globalAlpha = 0.8;
    
    // L√≠neas verticales
    for (let x = 0; x <= canvasWidth; x += cuadriculaTama√±o) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvasHeight);
        ctx.stroke();
    }
    
    // L√≠neas horizontales
    for (let y = 0; y <= canvasHeight; y += cuadriculaTama√±o) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvasWidth, y);
        ctx.stroke();
    }
    
    // L√≠neas de metro m√°s gruesas
    ctx.strokeStyle = '#cbd5e1';
    ctx.lineWidth = 1;
    
    for (let x = 0; x <= canvasWidth; x += escalaPixelsPorMetro) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvasHeight);
        ctx.stroke();
    }
    
    for (let y = 0; y <= canvasHeight; y += escalaPixelsPorMetro) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvasWidth, y);
        ctx.stroke();
    }
    
    ctx.restore();
}

// Funci√≥n mejorada para dibujar l√≠mites del canvas
function dibujarLimites() {
    ctx.save();
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = 3;
    ctx.strokeRect(0, 0, canvasWidth, canvasHeight);
    ctx.restore();
}

// Funci√≥n para dibujar regla de escala
function dibujarEscala() {
    ctx.save();
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(canvasWidth - 150, canvasHeight - 30, 140, 25);
    
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(canvasWidth - 140, canvasHeight - 15);
    ctx.lineTo(canvasWidth - 140 + escalaPixelsPorMetro, canvasHeight - 15);
    ctx.stroke();
    
    // Marcas en los extremos
    ctx.beginPath();
    ctx.moveTo(canvasWidth - 140, canvasHeight - 18);
    ctx.lineTo(canvasWidth - 140, canvasHeight - 12);
    ctx.moveTo(canvasWidth - 140 + escalaPixelsPorMetro, canvasHeight - 18);
    ctx.lineTo(canvasWidth - 140 + escalaPixelsPorMetro, canvasHeight - 12);
    ctx.stroke();
    
    ctx.fillStyle = '#ffffff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('1m', canvasWidth - 140 + escalaPixelsPorMetro/2, canvasHeight - 5);
    ctx.restore();
}

// Funci√≥n para dibujar escala fija (no afectada por zoom)
function dibujarEscalaFija() {
    ctx.save();
    
    // Posici√≥n fija en la esquina inferior derecha
    const escalaX = canvas.width - 160;
    const escalaY = canvas.height - 40;
    
    // Fondo del indicador de escala
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(escalaX, escalaY, 150, 30);
    
    // L√≠nea de escala (representando 1 metro a la escala actual)
    const escalaPixels = escalaPixelsPorMetro * zoom;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(escalaX + 10, escalaY + 20);
    ctx.lineTo(escalaX + 10 + Math.min(escalaPixels, 120), escalaY + 20);
    ctx.stroke();
    
    // Marcas en los extremos
    ctx.beginPath();
    ctx.moveTo(escalaX + 10, escalaY + 15);
    ctx.lineTo(escalaX + 10, escalaY + 25);
    ctx.moveTo(escalaX + 10 + Math.min(escalaPixels, 120), escalaY + 15);
    ctx.lineTo(escalaX + 10 + Math.min(escalaPixels, 120), escalaY + 25);
    ctx.stroke();
    
    // Texto de escala
    ctx.fillStyle = '#ffffff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    const metros = escalaPixels > 120 ? (120 / escalaPixels).toFixed(1) : '1';
    ctx.fillText(`${metros}m`, escalaX + 10 + Math.min(escalaPixels, 120) / 2, escalaY + 12);
    
    ctx.restore();
}

// Funci√≥n redraw mejorada que maneja mejor zoom y coordenadas
function redraw() {
    // Limpiar canvas completamente
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Guardar contexto y aplicar transformaciones de zoom/pan
    ctx.save();
    ctx.translate(panOffset.x, panOffset.y);
    ctx.scale(zoom, zoom);
    
    // Dibujar fondo
    ctx.fillStyle = '#f8fafc';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    
    // Dibujar cuadr√≠cula
    dibujarCuadricula();
    
    // Dibujar l√≠mites del √°rea v√°lida
    dibujarLimites();
    
    // Dibujar todos los objetos del piso actual
    objetos.forEach(objeto => {
        dibujarObjeto(objeto);
    });
    
    // Restaurar contexto
    ctx.restore();
    
    // Dibujar escala (siempre visible, fuera de las transformaciones)
    dibujarEscalaFija();
    
    // Actualizar contador de objetos
    actualizarContadorObjetos();
}

// üé® FUNCIONES DE DIBUJO DE OBJETOS

function dibujarObjeto(objeto) {
    ctx.save();
    
    // Aplicar selecci√≥n
    if (objeto === objetoSeleccionado) {
        ctx.shadowColor = '#3b82f6';
        ctx.shadowBlur = 8;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
    }
    
    // Dibujar seg√∫n el tipo
    switch (objeto.tipo) {
        case 'mesa':
            dibujarMesa(objeto);
            break;
        case 'silla':
            dibujarSilla(objeto);
            break;
        case 'pared':
            dibujarPared(objeto);
            break;
        case 'puerta':
            dibujarPuerta(objeto);
            break;
        case 'barra':
            dibujarBarra(objeto);
            break;
        default:
            dibujarObjetoGenerico(objeto);
    }
    
    ctx.restore();
}

function dibujarMesa(objeto) {
    // Fondo de la mesa
    ctx.fillStyle = objeto.color || '#DEB887';
    ctx.fillRect(objeto.x, objeto.y, objeto.width, objeto.height);
    
    // Borde
    ctx.strokeStyle = '#8B4513';
    ctx.lineWidth = 2;
    ctx.strokeRect(objeto.x, objeto.y, objeto.width, objeto.height);
    
    // Texto con n√∫mero de mesa
    if (objeto.propiedades?.numero) {
        ctx.fillStyle = '#000';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(
            objeto.propiedades.numero,
            objeto.x + objeto.width / 2,
            objeto.y + objeto.height / 2 - 8
        );
    }
    
    // Capacidad
    if (objeto.propiedades?.capacidad) {
        ctx.fillStyle = '#666';
        ctx.font = '10px Arial';
        ctx.fillText(
            `${objeto.propiedades.capacidad}p`,
            objeto.x + objeto.width / 2,
            objeto.y + objeto.height / 2 + 8
        );
    }
}

function dibujarSilla(objeto) {
    ctx.fillStyle = objeto.color || '#8B4513';
    ctx.fillRect(objeto.x, objeto.y, objeto.width, objeto.height);
    
    ctx.strokeStyle = '#654321';
    ctx.lineWidth = 1;
    ctx.strokeRect(objeto.x, objeto.y, objeto.width, objeto.height);
    
    // Respaldo de la silla
    ctx.fillRect(objeto.x + objeto.width * 0.8, objeto.y, objeto.width * 0.2, objeto.height);
}

function dibujarPared(objeto) {
    ctx.fillStyle = objeto.color || '#696969';
    ctx.fillRect(objeto.x, objeto.y, objeto.width, objeto.height);
    
    // Patr√≥n de ladrillos
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 1;
    
    const ladrilloWidth = 20;
    const ladrilloHeight = 10;
    
    for (let x = objeto.x; x < objeto.x + objeto.width; x += ladrilloWidth) {
        for (let y = objeto.y; y < objeto.y + objeto.height; y += ladrilloHeight) {
            ctx.strokeRect(x, y, Math.min(ladrilloWidth, objeto.x + objeto.width - x), 
                          Math.min(ladrilloHeight, objeto.y + objeto.height - y));
        }
    }
}

function dibujarPuerta(objeto) {
    // Marco de la puerta
    ctx.fillStyle = objeto.color || '#CD853F';
    ctx.fillRect(objeto.x, objeto.y, objeto.width, objeto.height);
    
    ctx.strokeStyle = '#8B4513';
    ctx.lineWidth = 2;
    ctx.strokeRect(objeto.x, objeto.y, objeto.width, objeto.height);
    
    // Indicador de apertura
    ctx.fillStyle = '#FFD700';
    ctx.beginPath();
    ctx.arc(objeto.x + objeto.width * 0.8, objeto.y + objeto.height / 2, 3, 0, 2 * Math.PI);
    ctx.fill();
}

function dibujarBarra(objeto) {
    // Superficie de la barra
    ctx.fillStyle = objeto.color || '#8B4513';
    ctx.fillRect(objeto.x, objeto.y, objeto.width, objeto.height);
    
    // Borde m√°s oscuro
    ctx.strokeStyle = '#654321';
    ctx.lineWidth = 2;
    ctx.strokeRect(objeto.x, objeto.y, objeto.width, objeto.height);
    
    // Decoraci√≥n de barra
    ctx.fillStyle = '#D2691E';
    ctx.fillRect(objeto.x + 5, objeto.y + 5, objeto.width - 10, objeto.height - 10);
    
    // Texto "BARRA"
    ctx.fillStyle = '#000';
    ctx.font = 'bold 10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('BARRA', objeto.x + objeto.width / 2, objeto.y + objeto.height / 2);
}

function dibujarObjetoGenerico(objeto) {
    ctx.fillStyle = objeto.color || '#CCCCCC';
    ctx.fillRect(objeto.x, objeto.y, objeto.width, objeto.height);
    
    ctx.strokeStyle = '#888888';
    ctx.lineWidth = 1;
    ctx.strokeRect(objeto.x, objeto.y, objeto.width, objeto.height);
}

// üîß FUNCIONES PRINCIPALES

// Selecci√≥n de herramientas
function seleccionarHerramienta(herramienta) {
    // Remover clase activa de todos los botones
    document.querySelectorAll('[id^="tool-"]').forEach(btn => {
        btn.classList.remove('tool-active');
    });
    
    // Activar herramienta seleccionada
    const boton = document.getElementById(`tool-${herramienta}`);
    if (boton) {
        boton.classList.add('tool-active');
    }
    
    herramientaActual = herramienta;
    objetoSeleccionado = null;
    actualizarPanelPropiedades();
    
    // Cambiar cursor
    switch (herramienta) {
        case 'seleccionar':
        case 'mover':
            if (canvas) canvas.style.cursor = 'default';
            break;
        case 'pan':
            if (canvas) canvas.style.cursor = 'grab';
            break;
        default:
            if (canvas) canvas.style.cursor = 'crosshair';
    }
    
    redraw();
}

// Guardar layout
function guardarLayout() {
    // Guardar objetos del piso actual
    objetosPorPiso[pisoActual] = [...objetos];
    
    const layout = {
        sucursalId: SUCURSAL_ID,
        objetos: [],
        version: '2.0',
        pisos: objetosPorPiso
    };
    
    // Consolidar todos los objetos de todos los pisos
    for (const [piso, objetosPiso] of Object.entries(objetosPorPiso)) {
        objetosPiso.forEach(obj => {
            layout.objetos.push({
                ...obj,
                piso: parseInt(piso)
            });
        });
    }
    
    // Obtener CSRF token
    let csrfToken = '';
    const csrfInput = document.querySelector('[name=csrfmiddlewaretoken]');
    if (csrfInput) {
        csrfToken = csrfInput.value;
    }
    
    console.log('üîë CSRF Token para guardar:', csrfToken);
    
    fetch('/dashboard/api/croquis/guardar/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrfToken
        },
        body: JSON.stringify(layout)
    })
    .then(response => {
        console.log('üì° Respuesta de guardar:', response.status, response.statusText);
        
        if (response.status === 401) {
            throw new Error('Sesi√≥n expirada. Por favor, inicia sesi√≥n nuevamente.');
        }
        
        if (response.status === 403) {
            throw new Error('No tienes permisos para guardar layouts. Se requieren permisos de administrador.');
        }
        
        if (!response.ok) {
            throw new Error(`Error HTTP ${response.status}: ${response.statusText}`);
        }
        
        return response.json();
    })
    .then(data => {
        if (data.success) {
            showToast('üíæ Layout guardado exitosamente', 'success');
        } else {
            showToast(`‚ùå Error: ${data.message}`, 'error');
        }
    })
    .catch(error => {
        console.error('Error guardando layout:', error);
        showToast(`‚ùå Error de conexi√≥n: ${error.message}`, 'error');
    });
}

// Cargar layout
function cargarLayout() {
    const sucursalId = SUCURSAL_ID;
    
    fetch(`/dashboard/api/croquis/cargar/${sucursalId}/`)
        .then(response => response.json())
        .then(data => {
            if (data.success && data.layout) {
                // Limpiar objetos actuales
                objetosPorPiso = { 1: [], 2: [], 3: [] };
                
                // Organizar objetos por piso
                if (data.layout.objetos) {
                    data.layout.objetos.forEach(obj => {
                        const piso = obj.piso || 1;
                        if (!objetosPorPiso[piso]) {
                            objetosPorPiso[piso] = [];
                        }
                        objetosPorPiso[piso].push(obj);
                    });
                }
                
                // Cargar objetos del piso actual
                objetos = objetosPorPiso[pisoActual] || [];
                objetoSeleccionado = null;
                
                actualizarPanelPropiedades();
                redraw();
                actualizarListaMesas();
                
                showToast('üìÇ Layout cargado exitosamente', 'success');
            } else {
                showToast('‚ö†Ô∏è No hay layout guardado para esta sucursal', 'warning');
            }
        })
        .catch(error => {
            console.error('Error cargando layout:', error);
            showToast('‚ùå Error cargando layout', 'error');
        });
}

// Eliminar objeto seleccionado
function eliminarSeleccionado() {
    if (objetoSeleccionado) {
        const index = objetos.indexOf(objetoSeleccionado);
        if (index > -1) {
            objetos.splice(index, 1);
            objetoSeleccionado = null;
            actualizarPanelPropiedades();
            redraw();
            showToast('üóëÔ∏è Objeto eliminado', 'success');
        }
    } else {
        showToast('‚ö†Ô∏è Selecciona un objeto para eliminar', 'warning');
    }
}

// Duplicar objeto seleccionado
function duplicarSeleccionado() {
    if (!objetoSeleccionado) {
        showToast('‚ö†Ô∏è Selecciona un objeto para duplicar', 'warning');
        return;
    }
    
    const nuevo = {
        ...objetoSeleccionado,
        id: Date.now() + Math.random(),
        x: objetoSeleccionado.x + 20,
        y: objetoSeleccionado.y + 20
    };
    
    objetos.push(nuevo);
    objetoSeleccionado = nuevo;
    actualizarPanelPropiedades();
    redraw();
    
    showToast('‚úÖ Objeto duplicado', 'success');
}

// Limpiar piso actual
function limpiarPiso() {
    if (objetos.length === 0) {
        showToast('‚ö†Ô∏è No hay objetos en este piso para limpiar', 'warning');
        return;
    }
    
    if (confirm(`¬øEst√°s seguro de que deseas limpiar todos los objetos del ${pisoActual === 1 ? 'planta baja' : `piso ${pisoActual}`}?`)) {
        objetos = [];
        objetosPorPiso[pisoActual] = [];
        objetoSeleccionado = null;
        actualizarPanelPropiedades();
        redraw();
        showToast('üßπ Piso limpiado', 'success');
    }
}

// Funciones de zoom
function zoomIn() {
    zoom *= 1.2;
    zoom = Math.min(3, zoom);
    document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
    redraw();
}

function zoomOut() {
    zoom *= 0.8;
    zoom = Math.max(0.3, zoom);
    document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
    redraw();
}

// Centrar vista (mejorada)
function centrarVista() {
    panOffset.x = 0;
    panOffset.y = 0;
    zoom = 1;
    document.getElementById('zoomLevel').textContent = '100%';
    redraw();
    showToast('üéØ Vista centrada - Coordenadas reiniciadas a 0,0', 'info');
}

// Recentrar vista del canvas
function recentrarVista() {
    zoom = 1;
    panOffset.x = 0;
    panOffset.y = 0;
    
    document.getElementById('zoomLevel').textContent = '100%';
    redraw();
    showToast('Vista recentrada', 'info');
}

// Ajustar vista al contenido
function ajustarTama√±o() {
    if (objetos.length === 0) {
        centrarVista();
        return;
    }
    
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    objetos.forEach(obj => {
        minX = Math.min(minX, obj.x);
        minY = Math.min(minY, obj.y);
        maxX = Math.max(maxX, obj.x + obj.width);
        maxY = Math.max(maxY, obj.y + obj.height);
    });
    
    const contentWidth = maxX - minX;
    const contentHeight = maxY - minY;
    const padding = 50;
    
    const zoomX = (canvas.width - padding * 2) / contentWidth;
    const zoomY = (canvas.height - padding * 2) / contentHeight;
    
    zoom = Math.min(zoomX, zoomY, 2);
    zoom = Math.max(zoom, 0.3);
    
    panOffset.x = (canvas.width - contentWidth * zoom) / 2 - minX * zoom;
    panOffset.y = (canvas.height - contentHeight * zoom) / 2 - minY * zoom;
    
    document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
    redraw();
    
    showToast('üîç Vista ajustada al contenido', 'info');
}

// Panel de propiedades
function actualizarPanelPropiedades() {
    const panel = document.getElementById('propiedadesPanel');
    
    if (!objetoSeleccionado) {
        panel.innerHTML = `
            <p class="text-muted text-center">
                <i class="fas fa-hand-pointer fa-2x mb-2 d-block"></i>
                Selecciona un objeto para ver sus propiedades
            </p>
        `;
        return;
    }
    
    const obj = objetoSeleccionado;
    
    let html = `
        <div class="property-group">
            <div class="property-label">Tipo de Objeto</div>
            <input type="text" class="form-control form-control-sm" value="${obj.tipo}" readonly>
        </div>
        
        <div class="property-group">
            <div class="property-label">Posici√≥n</div>
            <div class="row g-1">
                <div class="col-6">
                    <label class="form-label small">X:</label>
                    <input type="number" class="form-control form-control-sm" value="${Math.round(obj.x)}" 
                           onchange="actualizarPropiedad('x', parseFloat(this.value))">
                </div>
                <div class="col-6">
                    <label class="form-label small">Y:</label>
                    <input type="number" class="form-control form-control-sm" value="${Math.round(obj.y)}" 
                           onchange="actualizarPropiedad('y', parseFloat(this.value))">
                </div>
            </div>
        </div>
        
        <div class="property-group">
            <div class="property-label">Tama√±o</div>
            <div class="row g-1">
                <div class="col-6">
                    <label class="form-label small">Ancho:</label>
                    <input type="number" class="form-control form-control-sm" value="${Math.round(obj.width)}" 
                           onchange="actualizarPropiedad('width', parseFloat(this.value))">
                </div>
                <div class="col-6">
                    <label class="form-label small">Alto:</label>
                    <input type="number" class="form-control form-control-sm" value="${Math.round(obj.height)}" 
                           onchange="actualizarPropiedad('height', parseFloat(this.value))">
                </div>
            </div>
        </div>
    `;
    
    // Mostrar rotaci√≥n para objetos rotables
    if (obj.rotable) {
        const orientacion = obj.rotacion === 0 ? 'Horizontal' : 'Vertical';
        html += `
            <div class="property-group">
                <div class="property-label">Orientaci√≥n</div>
                <div class="d-flex gap-2 align-items-center">
                    <span class="badge bg-info">${orientacion}</span>
                    <button class="btn btn-outline-primary btn-sm" onclick="rotarObjeto(objetoSeleccionado)">
                        <i class="fas fa-redo-alt me-1"></i>Rotar
                    </button>
                </div>
                <small class="text-muted">Tambi√©n puedes hacer doble-click sobre el objeto para rotarlo</small>
            </div>
        `;
    }
    
    // Propiedades espec√≠ficas para mesas
    if (obj.tipo === 'mesa') {
        html += `
            <div class="property-group">
                <div class="property-label">Mesa</div>
                <div class="mb-2">
                    <label class="form-label small">N√∫mero:</label>
                    <input type="text" class="form-control form-control-sm" 
                           value="${obj.propiedades?.numero || ''}" 
                           onchange="actualizarPropiedadEspecifica('numero', this.value)"
                           placeholder="Ej: 1, A1, VIP1">
                </div>
                <div class="mb-2">
                    <label class="form-label small">Capacidad:</label>
                    <select class="form-select form-select-sm" 
                            onchange="actualizarPropiedadEspecifica('capacidad', parseInt(this.value))">
                        <option value="2" ${obj.propiedades?.capacidad === 2 ? 'selected' : ''}>2 personas</option>
                        <option value="4" ${obj.propiedades?.capacidad === 4 ? 'selected' : ''}>4 personas</option>
                        <option value="6" ${obj.propiedades?.capacidad === 6 ? 'selected' : ''}>6 personas</option>
                        <option value="8" ${obj.propiedades?.capacidad === 8 ? 'selected' : ''}>8 personas</option>
                        <option value="10" ${obj.propiedades?.capacidad === 10 ? 'selected' : ''}>10 personas</option>
                        <option value="12" ${obj.propiedades?.capacidad === 12 ? 'selected' : ''}>12 personas</option>
                    </select>
                </div>
            </div>
        `;
    }
    
    html += `
        <div class="property-group">
            <div class="d-grid gap-2">
                <button class="btn btn-danger btn-sm" onclick="eliminarSeleccionado()">
                    <i class="fas fa-trash me-1"></i>Eliminar Objeto
                </button>
                <button class="btn btn-secondary btn-sm" onclick="duplicarSeleccionado()">
                    <i class="fas fa-copy me-1"></i>Duplicar Objeto
                </button>
            </div>
        </div>
    `;
    
    panel.innerHTML = html;
}

// Actualizar propiedades de objeto
function actualizarPropiedad(propiedad, valor) {
    if (objetoSeleccionado) {
        objetoSeleccionado[propiedad] = valor;
        redraw();
    }
}

function actualizarPropiedadEspecifica(propiedad, valor) {
    if (objetoSeleccionado) {
        if (!objetoSeleccionado.propiedades) {
            objetoSeleccionado.propiedades = {};
        }
        objetoSeleccionado.propiedades[propiedad] = valor;
        redraw();
    }
}

// Funci√≥n para mostrar notificaciones
function showToast(message, type = 'info') {
    // Crear toast container si no existe
    let container = document.getElementById('toastContainer');
    if (!container) {
        container = document.createElement('div');
        container.id = 'toastContainer';
        container.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 9999;';
        document.body.appendChild(container);
    }
    
    // Crear toast
    const toast = document.createElement('div');
    toast.className = `alert alert-${type === 'error' ? 'danger' : type} alert-dismissible fade show`;
    toast.style.cssText = 'min-width: 250px; margin-bottom: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);';
    toast.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    container.appendChild(toast);
    
    // Auto-remove despu√©s de 3 segundos
    setTimeout(() => {
        if (toast.parentNode) {
            toast.remove();
        }
    }, 3000);
}

// üìä FUNCIONES DE GESTI√ìN DE MESAS

// Cargar mesas disponibles desde el servidor
function cargarMesasDisponibles() {
    const sucursalId = SUCURSAL_ID;
    const url = `/dashboard/api/croquis/mesas/${sucursalId}/`;
    
    console.log('üîÑ Cargando mesas desde:', url);
    
    fetch(url)
        .then(response => {
            console.log('üì° Respuesta recibida:', response.status, response.statusText);
            
            if (response.status === 401) {
                console.error('‚ùå Error de autenticaci√≥n');
                showToast('‚ö†Ô∏è Sesi√≥n expirada. Por favor, inicia sesi√≥n nuevamente.', 'warning');
                return null;
            }
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            return response.json();
        })
        .then(data => {
            if (data && data.success) {
                mesasDisponibles = data.mesas || [];
                console.log(`‚úÖ ${mesasDisponibles.length} mesas cargadas:`, mesasDisponibles);
                actualizarListaMesas();
                showToast(`üìã ${mesasDisponibles.length} mesas cargadas`, 'success');
            } else {
                console.warn('‚ö†Ô∏è No hay mesas disponibles o error en respuesta:', data);
                mesasDisponibles = [];
                actualizarListaMesas();
                showToast('‚ö†Ô∏è No hay mesas registradas para esta sucursal', 'warning');
            }
        })
        .catch(error => {
            console.error('‚ùå Error cargando mesas:', error);
            mesasDisponibles = [];
            actualizarListaMesas();
            showToast('‚ùå Error al cargar mesas. Revisa la conexi√≥n.', 'error');
        });
}

// Actualizar la lista visual de mesas en el panel lateral
function actualizarListaMesas() {
    const lista = document.getElementById('listaMesas');
    if (!lista) {
        console.warn('‚ö†Ô∏è No se encontr√≥ el elemento listaMesas');
        return;
    }
    
    if (!mesasDisponibles || mesasDisponibles.length === 0) {
        lista.innerHTML = `
            <div class="text-center p-3">
                <i class="fas fa-exclamation-triangle text-warning fa-2x mb-2"></i>
                <p class="text-muted mb-2">No hay mesas registradas para esta sucursal</p>
                <small class="text-muted">
                    Las mesas deben estar creadas en el sistema para poder vincularlas al croquis.
                </small>
            </div>
        `;
        return;
    }
    
    let html = '<div class="mb-3"><h6 class="text-muted small">MESAS REGISTRADAS</h6></div>';
    
    mesasDisponibles.forEach(mesa => {
        const objetoMesaVinculada = objetos.find(obj => obj.tipo === 'mesa' && obj.mesaId === mesa.id);
        const estaUbicada = !!objetoMesaVinculada;
        const claseEstado = estaUbicada ? 'mesa-ubicada' : 'mesa-disponible';
        
        html += `
            <div class="mesa-item ${claseEstado} mb-2" data-mesa-id="${mesa.id}">
                <div class="d-flex justify-content-between align-items-start">
                    <div class="flex-grow-1">
                        <div class="fw-bold">Mesa ${mesa.numero}</div>
                        <small class="text-muted">${mesa.capacidad} personas</small>
                        ${mesa.nombre ? `<small class="d-block text-info">${mesa.nombre}</small>` : ''}
                    </div>
                    <div class="text-end">
                        <span class="badge ${estaUbicada ? 'bg-success' : 'bg-secondary'} mb-1">
                            ${estaUbicada ? 'Ubicada' : 'Sin ubicar'}
                        </span>
                        ${estaUbicada ? `<small class="d-block text-muted">Piso ${objetoMesaVinculada.piso}</small>` : ''}
                    </div>
                </div>
            </div>
        `;
    });
    
    lista.innerHTML = html;
    
    // Agregar eventos de clic para vincular mesas
    lista.querySelectorAll('.mesa-item').forEach(item => {
        item.addEventListener('click', function() {
            const mesaId = parseInt(this.dataset.mesaId);
            vincularMesaAlCroquis(mesaId);
        });
    });
}

// Vincular una mesa del sistema a un objeto mesa en el croquis
function vincularMesaAlCroquis(mesaId) {
    const mesa = mesasDisponibles.find(m => m.id === mesaId);
    if (!mesa) {
        showToast('‚ùå Mesa no encontrada', 'error');
        return;
    }
    
    // Verificar si la mesa ya est√° ubicada
    const mesaExistente = objetos.find(obj => obj.tipo === 'mesa' && obj.mesaId === mesaId);
    if (mesaExistente) {
        showToast(`‚ö†Ô∏è Mesa ${mesa.numero} ya est√° ubicada en el piso ${mesaExistente.piso}`, 'warning');
        return;
    }
    
    // Crear nueva mesa en el centro del canvas
    const centerX = canvasWidth / 2 - 30;
    const centerY = canvasHeight / 2 - 30;
    
    const nuevaMesa = {
        id: Date.now(),
        tipo: 'mesa',
        x: centerX,
        y: centerY,
        width: 60,
        height: 60,
        color: '#DEB887',
        piso: pisoActual,
        mesaId: mesaId,
        propiedades: {
            numero: mesa.numero.toString(),
            capacidad: mesa.capacidad
        }
    };
    
    objetos.push(nuevaMesa);
    objetoSeleccionado = nuevaMesa;
    
    actualizarContadorObjetos();
    actualizarPanelPropiedades();
    actualizarListaMesas();
    redraw();
    
    showToast(`‚úÖ Mesa ${mesa.numero} agregada al piso ${pisoActual}`, 'success');
}

// üè¢ FUNCIONES DE GESTI√ìN DE PISOS

// Cambiar entre pisos
function cambiarPiso(numeroPiso) {
    if (numeroPiso === pisoActual) {
        return; // Ya estamos en este piso
    }
    
    console.log(`üîÑ Cambiando del piso ${pisoActual} al piso ${numeroPiso}`);
    
    // Guardar objetos del piso actual
    objetosPorPiso[pisoActual] = [...objetos];
    
    // Cambiar al nuevo piso
    pisoActual = numeroPiso;
    
    // Cargar objetos del nuevo piso
    objetos = [...(objetosPorPiso[pisoActual] || [])];
    
    // Actualizar UI
    document.querySelectorAll('.piso-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    const botonPiso = document.getElementById(`piso-${numeroPiso}`);
    if (botonPiso) {
        botonPiso.classList.add('active');
    }
    
    // Actualizar indicadores
    const indicadorPiso = document.getElementById('indicadorPiso');
    if (indicadorPiso) {
        indicadorPiso.textContent = `Piso ${numeroPiso}`;
    }
    
    const objetosPisoSpan = document.getElementById('objetosPisoActual');
    if (objetosPisoSpan) {
        objetosPisoSpan.textContent = numeroPiso;
    }
    
    // Limpiar selecci√≥n
    objetoSeleccionado = null;
    
    // Actualizar contadores y listas
    actualizarContadorObjetos();
    actualizarListaMesas();
    actualizarPanelPropiedades();
    redraw();
    
    showToast(`üìç Cambiado a Piso ${numeroPiso}`, 'info');
}

// Agregar nuevo piso
function agregarPiso() {
    const siguientePiso = Math.max(...pisosDisponibles) + 1;
    
    if (siguientePiso > 5) {
        showToast('‚ö†Ô∏è M√°ximo 5 pisos permitidos', 'warning');
        return;
    }
    
    // Agregar piso a la lista
    pisosDisponibles.push(siguientePiso);
    objetosPorPiso[siguientePiso] = [];
    
    // Crear bot√≥n para el nuevo piso
    const grupoBotonsPiso = document.querySelector('.btn-group[role="group"]');
    if (grupoBotonsPiso) {
        const nuevoBoton = document.createElement('button');
        nuevoBoton.type = 'button';
        nuevoBoton.id = `piso-${siguientePiso}`;
        nuevoBoton.className = 'btn btn-outline-primary piso-btn';
        nuevoBoton.onclick = () => cambiarPiso(siguientePiso);
        nuevoBoton.textContent = siguientePiso;
        grupoBotonsPiso.appendChild(nuevoBoton);
    }
    
    // Cambiar autom√°ticamente al nuevo piso
    cambiarPiso(siguientePiso);
    
    showToast(`‚úÖ Piso ${siguientePiso} agregado`, 'success');
}

// Eliminar piso actual
function eliminarPiso() {
    if (pisosDisponibles.length <= 1) {
        showToast('‚ö†Ô∏è Debe mantener al menos un piso', 'warning');
        return;
    }
    
    if (objetos.length > 0) {
        if (!confirm(`¬øEst√° seguro de eliminar el Piso ${pisoActual}? Se perder√°n todos los objetos del piso.`)) {
            return;
        }
    }
    
    // Eliminar piso de la lista
    pisosDisponibles = pisosDisponibles.filter(p => p !== pisoActual);
    delete objetosPorPiso[pisoActual];
    
    // Eliminar bot√≥n del piso
    const botonPiso = document.getElementById(`piso-${pisoActual}`);
    if (botonPiso) {
        botonPiso.remove();
    }
    
    // Cambiar al primer piso disponible
    const primerPiso = Math.min(...pisosDisponibles);
    cambiarPiso(primerPiso);
    
    showToast(`üóëÔ∏è Piso ${pisoActual} eliminado`, 'info');
}

// üé® FUNCIONES ADICIONALES DEL EDITOR

// Alternar visibilidad de cuadr√≠cula
function alternarCuadricula() {
    cuadriculaVisible = !cuadriculaVisible;
    
    const botonCuadricula = document.querySelector('[onclick="alternarCuadricula()"]');
    if (botonCuadricula) {
        if (cuadriculaVisible) {
            botonCuadricula.classList.remove('btn-outline-secondary');
            botonCuadricula.classList.add('btn-secondary');
        } else {
            botonCuadricula.classList.remove('btn-secondary');
            botonCuadricula.classList.add('btn-outline-secondary');
        }
    }
    
    redraw();
    showToast(`Cuadr√≠cula ${cuadriculaVisible ? 'activada' : 'desactivada'}`, 'info');
}

// Actualizar dimensiones del canvas
function actualizarDimensiones() {
    const anchoInput = document.getElementById('anchoMetros');
    const altoInput = document.getElementById('altoMetros');
    const escalaSelect = document.getElementById('escalaSelect');
    const dimensionesInfo = document.getElementById('dimensionesInfo');
    const infoEscala = document.getElementById('infoEscala');
    
    if (anchoInput && altoInput && escalaSelect) {
        anchoMetros = parseInt(anchoInput.value) || 15;
        altoMetros = parseInt(altoInput.value) || 10;
        escalaPixelsPorMetro = parseInt(escalaSelect.value) || 30;
        
        // Calcular nuevas dimensiones del canvas
        canvasWidth = anchoMetros * escalaPixelsPorMetro;
        canvasHeight = altoMetros * escalaPixelsPorMetro;
        cuadriculaTama√±o = escalaPixelsPorMetro;
        
        // Actualizar canvas
        if (canvas) {
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            canvas.style.width = canvasWidth + 'px';
            canvas.style.height = canvasHeight + 'px';
        }
        
        // Actualizar informaci√≥n
        if (dimensionesInfo) {
            dimensionesInfo.textContent = `${canvasWidth} x ${canvasHeight} px`;
        }
        
        if (infoEscala) {
            infoEscala.textContent = `1m = ${escalaPixelsPorMetro}px`;
        }
        
        // Redibujar
        redraw();
        
        console.log(`üìê Dimensiones actualizadas: ${anchoMetros}m x ${altoMetros}m = ${canvasWidth}px x ${canvasHeight}px`);
    }
}

// Crear layout predefinido
function crearLayoutPredefinido() {
    if (objetos.length > 0) {
        if (!confirm('¬øDesea reemplazar el layout actual con uno predefinido?')) {
            return;
        }
    }
    
    // Limpiar objetos actuales
    objetos = [];
    
    const margen = 30; // Margen desde los bordes
    
    // Crear paredes perimetrales
    // Pared superior
    objetos.push({
        id: Date.now() + 1,
        tipo: 'pared',
        x: 0,
        y: 0,
        width: canvasWidth,
        height: 20,
        color: '#8B4513',
        piso: pisoActual
    });
    
    // Pared inferior
    objetos.push({
        id: Date.now() + 2,
        tipo: 'pared',
        x: 0,
        y: canvasHeight - 20,
        width: canvasWidth,
        height: 20,
        color: '#8B4513',
        piso: pisoActual
    });
    
    // Pared izquierda
    objetos.push({
        id: Date.now() + 3,
        tipo: 'pared',
        x: 0,
        y: 20,
        width: 20,
        height: canvasHeight - 40,
        color: '#8B4513',
        piso: pisoActual
    });
    
    // Pared derecha
    objetos.push({
        id: Date.now() + 4,
        tipo: 'pared',
        x: canvasWidth - 20,
        y: 20,
        width: 20,
        height: canvasHeight - 40,
        color: '#8B4513',
        piso: pisoActual
    });
    
    // Puerta de entrada
    objetos.push({
        id: Date.now() + 5,
        tipo: 'puerta',
        x: canvasWidth / 2 - 40,
        y: canvasHeight - 20,
        width: 80,
        height: 20,
        color: '#654321',
        piso: pisoActual
    });
    
    // Barra del sushi (horizontal, en la parte superior)
    objetos.push({
        id: Date.now() + 6,
        tipo: 'barra',
        x: margen * 2,
        y: margen * 2,
        width: canvasWidth - margen * 6,
        height: 40,
        color: '#8B0000',
        piso: pisoActual
    });
    
    // Mesas distribuidas en el √°rea del comedor
    const mesaWidth = 60;
    const mesaHeight = 60;
    const espaciadoX = 120;
    const espaciadoY = 100;
    const inicioY = 120; // Despu√©s de la barra
    
    let mesaCounter = 1;
    for (let y = inicioY; y < canvasHeight - margen * 3; y += espaciadoY) {
        for (let x = margen * 2; x < canvasWidth - margen * 3; x += espaciadoX) {
            if (x + mesaWidth < canvasWidth - margen * 2 && y + mesaHeight < canvasHeight - margen * 3) {
                objetos.push({
                    id: Date.now() + 10 + mesaCounter,
                    tipo: 'mesa',
                    x: x,
                    y: y,
                    width: mesaWidth,
                    height: mesaHeight,
                    color: '#DEB887',
                    piso: pisoActual,
                    propiedades: {
                        numero: mesaCounter.toString(),
                        capacidad: 4
                    }
                });
                
                // Agregar sillas alrededor de cada mesa
                const sillas = [
                    { x: x - 25, y: y + 15, w: 20, h: 30 }, // Izquierda
                    { x: x + mesaWidth + 5, y: y + 15, w: 20, h: 30 }, // Derecha
                    { x: x + 15, y: y - 25, w: 30, h: 20 }, // Arriba
                    { x: x + 15, y: y + mesaHeight + 5, w: 30, h: 20 } // Abajo
                ];
                
                sillas.forEach((silla, index) => {
                    if (silla.x >= margen && silla.y >= margen && 
                        silla.x + silla.w <= canvasWidth - margen && 
                        silla.y + silla.h <= canvasHeight - margen) {
                        objetos.push({
                            id: Date.now() + 100 + mesaCounter * 10 + index,
                            tipo: 'silla',
                            x: silla.x,
                            y: silla.y,
                            width: silla.w,
                            height: silla.h,
                            color: '#8B4513',
                            piso: pisoActual
                        });
                    }
                });
                
                mesaCounter++;
            }
        }
    }
    
    // Guardar en el piso actual
    objetosPorPiso[pisoActual] = [...objetos];
    
    // Actualizar vista
    actualizarContadorObjetos();
    redraw();
    
    showToast(`üèóÔ∏è Layout predefinido creado con ${objetos.length} elementos`, 'success');
}

// üìä FUNCIONES DE ACTUALIZACI√ìN DE UI

// Actualizar contador de objetos en el piso actual
function actualizarContadorObjetos() {
    const contadorElement = document.getElementById('contadorObjetos');
    if (contadorElement) {
        contadorElement.textContent = objetos.length;
    }
}

// üñ±Ô∏è FUNCIONES DE EVENTOS DEL MOUSE

// Obtener posici√≥n del mouse relativa al canvas (corregida para coordenadas exactas)
function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    // Calcular posici√≥n exacta sin transformaciones de zoom/pan
    const x = (e.clientX - rect.left);
    const y = (e.clientY - rect.top);
    
    // Ajustar por zoom y pan si est√°n aplicados
    return {
        x: (x - panOffset.x) / zoom,
        y: (y - panOffset.y) / zoom
    };
}

// Detectar si el mouse est√° sobre un objeto
function getObjectAt(x, y) {
    // Buscar en orden inverso para detectar el objeto "m√°s arriba"
    for (let i = objetos.length - 1; i >= 0; i--) {
        const obj = objetos[i];
        if (x >= obj.x && x <= obj.x + obj.width &&
            y >= obj.y && y <= obj.y + obj.height) {
            return obj;
        }
    }
    return null;
}

// Evento mouse down
function onMouseDown(e) {
    e.preventDefault();
    const pos = getMousePos(e);
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    
    if (herramientaActual === 'seleccionar') {
        // Seleccionar objeto
        const objeto = getObjectAt(pos.x, pos.y);
        if (objeto) {
            objetoSeleccionado = objeto;
            isDragging = true;
            dragOffset.x = pos.x - objeto.x;
            dragOffset.y = pos.y - objeto.y;
            canvas.style.cursor = 'grabbing';
        } else {
            // Si no hay objeto, activar pan
            objetoSeleccionado = null;
            isDragging = false;
            isPanning = true;
            panStartPos.x = e.clientX;
            panStartPos.y = e.clientY;
            canvas.style.cursor = 'grabbing';
        }
        actualizarPanelPropiedades();
        redraw();
    } else if (herramientaActual === 'pan') {
        // Modo pan espec√≠fico
        isPanning = true;
        panStartPos.x = e.clientX;
        panStartPos.y = e.clientY;
        canvas.style.cursor = 'grabbing';
    } else {
        // Crear nuevo objeto
        crearObjeto(pos.x, pos.y, herramientaActual);
    }
}

// Evento mouse move
function onMouseMove(e) {
    const pos = getMousePos(e);
    
    // Actualizar coordenadas en la interfaz (siempre desde 0,0)
    const coordDiv = document.getElementById('coordenadasDiv');
    if (coordDiv) {
        // Asegurar que las coordenadas empiecen desde 0,0
        const metrosX = Math.max(0, (pos.x / escalaPixelsPorMetro)).toFixed(1);
        const metrosY = Math.max(0, (pos.y / escalaPixelsPorMetro)).toFixed(1);
        coordDiv.textContent = `X: ${metrosX}m, Y: ${metrosY}m`;
    }
    
    if (isDragging && objetoSeleccionado && herramientaActual === 'seleccionar') {
        // Mover objeto seleccionado
        const newX = pos.x - dragOffset.x;
        const newY = pos.y - dragOffset.y;
        
        // Verificar l√≠mites del canvas (mantener objetos dentro)
        const maxX = canvasWidth - objetoSeleccionado.width;
        const maxY = canvasHeight - objetoSeleccionado.height;
        
        objetoSeleccionado.x = Math.max(0, Math.min(maxX, newX));
        objetoSeleccionado.y = Math.max(0, Math.min(maxY, newY));
        redraw();
    } else if (isPanning) {
        // Pan con l√≠mites mejorados
        const deltaX = e.clientX - lastMouseX;
        const deltaY = e.clientY - lastMouseY;
        
        panOffset.x += deltaX;
        panOffset.y += deltaY;
        
        // Aplicar l√≠mites estrictos
        limitarPan();
        
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        
        redraw();
    } else if (herramientaActual !== 'seleccionar') {
        // Cambiar cursor para herramientas de creaci√≥n
        canvas.style.cursor = 'crosshair';
    } else {
        // Cambiar cursor seg√∫n si hay objeto bajo el mouse
        const objeto = getObjectAt(pos.x, pos.y);
        canvas.style.cursor = objeto ? 'grab' : 'default';
    }
}

// Evento mouse up
function onMouseUp(e) {
    if (isDragging) {
        isDragging = false;
        canvas.style.cursor = 'default';
        
        // Actualizar panel de propiedades con nueva posici√≥n
        actualizarPanelPropiedades();
    }
    
    if (isPanning) {
        isPanning = false;
        canvas.style.cursor = 'default';
    }
}

// Evento wheel (zoom mejorado que mantiene objetos visibles)
function onWheel(e) {
    e.preventDefault();
    
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    const newZoom = zoom * zoomFactor;
    
    // Limitar zoom entre 50% y 200%
    if (newZoom >= 0.5 && newZoom <= 2) {
        const prevZoom = zoom;
        zoom = newZoom;
        
        // Ajustar pan para hacer zoom hacia la posici√≥n del mouse
        panOffset.x = mouseX - (mouseX - panOffset.x) * (zoom / prevZoom);
        panOffset.y = mouseY - (mouseY - panOffset.y) * (zoom / prevZoom);
        
        // Aplicar l√≠mites estrictos de pan para no perder el canvas
        limitarPan();
        
        document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
        redraw();
    }
}

// Funci√≥n para limitar el pan y mantener siempre visible el √°rea de trabajo
function limitarPan() {
    const margenSeguridad = 100; // P√≠xeles de margen para mantener algo visible
    
    // Calcular las dimensiones reales del contenido escalado
    const contenidoScaladoWidth = canvasWidth * zoom;
    const contenidoScaladoHeight = canvasHeight * zoom;
    
    // Calcular l√≠mites m√°s estrictos
    let minPanX, maxPanX, minPanY, maxPanY;
    
    if (zoom >= 1) {
        // Cuando est√° ampliado, permitir que el contenido se mueva pero mantener algo visible
        minPanX = -(contenidoScaladoWidth - margenSeguridad);
        maxPanX = margenSeguridad;
        minPanY = -(contenidoScaladoHeight - margenSeguridad);
        maxPanY = margenSeguridad;
    } else {
        // Cuando est√° reducido, centrar y permitir poco movimiento
        const centroX = (canvas.width - contenidoScaladoWidth) / 2;
        const centroY = (canvas.height - contenidoScaladoHeight) / 2;
        const margenMovimiento = 50; // Poco movimiento permitido
        
        minPanX = centroX - margenMovimiento;
        maxPanX = centroX + margenMovimiento;
        minPanY = centroY - margenMovimiento;
        maxPanY = centroY + margenMovimiento;
    }
    
    // Aplicar l√≠mites
    panOffset.x = Math.max(minPanX, Math.min(maxPanX, panOffset.x));
    panOffset.y = Math.max(minPanY, Math.min(maxPanY, panOffset.y));
    
    // Asegurar que el origen (0,0) est√© siempre visible si es posible
    const origenEnPantallaX = panOffset.x;
    const origenEnPantallaY = panOffset.y;
    
    // Si el origen est√° fuera de la pantalla, ajustar
    if (origenEnPantallaX < -canvas.width || origenEnPantallaX > canvas.width ||
        origenEnPantallaY < -canvas.height || origenEnPantallaY > canvas.height) {
        
        // Recentrar para mostrar al menos parte del √°rea de trabajo
        if (zoom >= 1) {
            panOffset.x = Math.max(-(contenidoScaladoWidth * 0.5), 
                          Math.min(0, panOffset.x));
            panOffset.y = Math.max(-(contenidoScaladoHeight * 0.5), 
                          Math.min(0, panOffset.y));
        }
    }
}

// Evento doble-click para rotar objetos
function onDoubleClick(e) {
    e.preventDefault();
    const pos = getMousePos(e);
    
    if (herramientaActual === 'seleccionar') {
        const objeto = getObjectAt(pos.x, pos.y);
        if (objeto && objeto.rotable) {
            rotarObjeto(objeto);
        }
    }
}

// Funci√≥n para rotar objetos
function rotarObjeto(objeto) {
    if (!objeto.rotable) return;
    
    // Intercambiar width y height
    const tempWidth = objeto.width;
    objeto.width = objeto.height;
    objeto.height = tempWidth;
    
    // Alternar rotaci√≥n
    objeto.rotacion = objeto.rotacion === 0 ? 1 : 0;
    
    // Verificar que el objeto rotado no se salga del canvas
    if (objeto.x + objeto.width > canvasWidth) {
        objeto.x = canvasWidth - objeto.width;
    }
    if (objeto.y + objeto.height > canvasHeight) {
        objeto.y = canvasHeight - objeto.height;
    }
    
    actualizarPanelPropiedades();
    redraw();
    
    const orientacion = objeto.rotacion === 0 ? 'horizontal' : 'vertical';
    showToast(`üîÑ ${objeto.tipo} rotad${objeto.tipo === 'mesa' ? 'a' : 'o'} a ${orientacion}`, 'info');
}

// üé® FUNCI√ìN PARA CREAR OBJETOS (mejorada con rotaci√≥n para paredes)

function crearObjeto(x, y, tipo) {
    // Verificar l√≠mites del canvas
    let width = 60, height = 60;
    let rotable = false; // Indica si el objeto se puede rotar
    
    switch (tipo) {
        case 'mesa':
            width = 60;
            height = 60;
            break;
        case 'silla':
            width = 30;
            height = 30;
            break;
        case 'pared':
            width = 100;
            height = 20;
            rotable = true; // Las paredes se pueden rotar
            break;
        case 'puerta':
            width = 80;
            height = 20;
            rotable = true; // Las puertas tambi√©n se pueden rotar
            break;
        case 'barra':
            width = 150;
            height = 40;
            rotable = true; // Las barras tambi√©n se pueden rotar
            break;
        default:
            width = 50;
            height = 50;
    }
    
    // Ajustar posici√≥n si el objeto se sale del canvas
    if (x + width > canvasWidth) x = canvasWidth - width;
    if (y + height > canvasHeight) y = canvasHeight - height;
    if (x <  0) x = 0;
    if (y < 0) y = 0;
    
    const nuevoObjeto = {
        id: Date.now() + Math.random(),
        tipo: tipo,
        x: x,
        y: y,
        width: width,
        height: height,
        color: getColorForType(tipo),
        piso: pisoActual,
        rotacion: 0, // Nueva propiedad para rotaci√≥n (0 = horizontal, 1 = vertical)
        rotable: rotable // Indica si se puede rotar
    };
    
    // Propiedades espec√≠ficas para mesas
    if (tipo === 'mesa') {
        nuevoObjeto.propiedades = {
            numero: (objetos.filter(obj => obj.tipo === 'mesa').length + 1).toString(),
            capacidad: 4
        };
    }
    
    objetos.push(nuevoObjeto);
    objetoSeleccionado = nuevoObjeto;
    
    actualizarPanelPropiedades();
    redraw();
    
    showToast(`‚úÖ ${tipo.charAt(0).toUpperCase() + tipo.slice(1)} agregad${tipo === 'mesa' ? 'a' : 'o'} - ${rotable ? 'Doble-click para rotar' : ''}`, 'success');
}

// Obtener color por defecto seg√∫n el tipo de objeto
function getColorForType(tipo) {
    switch (tipo) {
        case 'mesa': return '#DEB887';
        case 'silla': return '#8B4513';
        case 'pared': return '#696969';
        case 'puerta': return '#CD853F';
        case 'barra': return '#8B0000';
        default: return '#CCCCCC';
    }
}

// üåê EXPOSICI√ìN DE FUNCIONES GLOBALES
// Exponer todas las funciones necesarias para onclick handlers
window.seleccionarHerramienta = seleccionarHerramienta;
window.guardarLayout = guardarLayout;
window.cargarLayout = cargarLayout;
window.limpiarPiso = limpiarPiso;
window.eliminarSeleccionado = eliminarSeleccionado;
window.duplicarSeleccionado = duplicarSeleccionado;
window.centrarVista = centrarVista;
window.recentrarVista = recentrarVista;
window.ajustarTama√±o = ajustarTama√±o;
window.zoomIn = zoomIn;
window.zoomOut = zoomOut;
window.actualizarDimensiones = actualizarDimensiones;
window.cambiarPiso = cambiarPiso;
window.agregarPiso = agregarPiso;
window.eliminarPiso = eliminarPiso;
window.crearLayoutPredefinido = crearLayoutPredefinido;
window.alternarCuadricula = alternarCuadricula;
window.recentrarVista = recentrarVista;
window.cargarMesasDisponibles = cargarMesasDisponibles;
window.actualizarListaMesas = actualizarListaMesas;
window.vincularMesaAlCroquis = vincularMesaAlCroquis;
window.rotarObjeto = rotarObjeto;

// üöÄ INICIALIZACI√ìN
// Inicializar editor cuando el DOM est√© listo
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Iniciando Editor de Croquis...');
    
    if (inicializarCanvas()) {
        console.log('‚úÖ Canvas inicializado correctamente');
        
        // Cargar configuraci√≥n inicial
        actualizarDimensiones();
        
        // Cargar layout existente
        cargarLayout();
        
        // Cargar mesas disponibles
        cargarMesasDisponibles();
        
        // Configurar escucha de eventos globales
        document.addEventListener('keydown', function(e) {
            if (objetoSeleccionado) {
                switch (e.key) {
                    case 'Delete':
                        eliminarSeleccionado();
                        break;
                    case 'Escape':
                        objetoSeleccionado = null;
                        seleccionarHerramienta('seleccionar');
                        actualizarPanelPropiedades();
                        redraw();
                        break;
                }
            }
        });
        
        console.log('üéâ Editor de Croquis iniciado correctamente');
        showToast('üé® Editor de Croquis listo para usar', 'success');
    } else {
        console.error('‚ùå Error inicializando el canvas');
        showToast('‚ùå Error inicializando el editor', 'error');
    }
});
</script>
{% endblock %}
